// This code was autogenerated with `dbus-codegen-rust -s -d org.freedesktop.systemd1 -p /org/freedesktop/systemd1`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_tree as tree;

pub trait OrgFreedesktopDBusPeer {
    fn ping(&self) -> Result<(), tree::MethodErr>;
    fn get_machine_id(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_freedesktop_dbus_peer_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusPeer,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Peer", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.ping()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Ping", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let machine_uuid = d.get_machine_id()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(machine_uuid);
        Ok(vec!(rm))
    };
    let m = factory.method("GetMachineId", Default::default(), h);
    let m = m.out_arg(("machine_uuid", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_freedesktop_dbus_introspectable_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusIntrospectable,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Introspectable", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let data = d.introspect()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(data);
        Ok(vec!(rm))
    };
    let m = factory.method("Introspect", Default::default(), h);
    let m = m.out_arg(("data", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusProperties {
    fn get(&self, interface: &str, property: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, tree::MethodErr>;
    fn get_all(&self, interface: &str) -> Result<arg::PropMap, tree::MethodErr>;
    fn set(&self, interface: &str, property: &str, value: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), tree::MethodErr>;
}

pub fn org_freedesktop_dbus_properties_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Signal: Default,
    T: OrgFreedesktopDBusProperties,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Properties", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let property: &str = i.read()?;
        let d = fclone(minfo);
        let value = d.get(interface, property)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec!(rm))
    };
    let m = factory.method("Get", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.in_arg(("property", "s"));
    let m = m.out_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let d = fclone(minfo);
        let properties = d.get_all(interface)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(properties);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAll", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.out_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let property: &str = i.read()?;
        let value: arg::Variant<Box<dyn arg::RefArg>> = i.read()?;
        let d = fclone(minfo);
        d.set(interface, property, value)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Set", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.in_arg(("property", "s"));
    let m = m.in_arg(("value", "v"));
    let i = i.add_m(m);
    let s = factory.signal("PropertiesChanged", Default::default());
    let s = s.arg(("interface", "s"));
    let s = s.arg(("changed_properties", "a{sv}"));
    let s = s.arg(("invalidated_properties", "as"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub trait OrgFreedesktopSystemd1Manager {
    fn get_unit(&self, name: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_unit_by_pid(&self, pid: u32) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_unit_by_invocation_id(&self, invocation_id: Vec<u8>) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_unit_by_control_group(&self, cgroup: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn load_unit(&self, name: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn start_unit(&self, name: &str, mode: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn start_unit_replace(&self, old_unit: &str, new_unit: &str, mode: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn stop_unit(&self, name: &str, mode: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn reload_unit(&self, name: &str, mode: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn restart_unit(&self, name: &str, mode: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn try_restart_unit(&self, name: &str, mode: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn reload_or_restart_unit(&self, name: &str, mode: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn reload_or_try_restart_unit(&self, name: &str, mode: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn enqueue_unit_job(&self, name: &str, job_type: &str, job_mode: &str) -> Result<(u32, dbus::Path<'static>, String, dbus::Path<'static>, String, Vec<(u32, dbus::Path<'static>, String, dbus::Path<'static>, String)>), tree::MethodErr>;
    fn kill_unit(&self, name: &str, whom: &str, signal: i32) -> Result<(), tree::MethodErr>;
    fn clean_unit(&self, name: &str, mask: Vec<&str>) -> Result<(), tree::MethodErr>;
    fn freeze_unit(&self, name: &str) -> Result<(), tree::MethodErr>;
    fn thaw_unit(&self, name: &str) -> Result<(), tree::MethodErr>;
    fn reset_failed_unit(&self, name: &str) -> Result<(), tree::MethodErr>;
    fn set_unit_properties(&self, name: &str, runtime: bool, properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>) -> Result<(), tree::MethodErr>;
    fn ref_unit(&self, name: &str) -> Result<(), tree::MethodErr>;
    fn unref_unit(&self, name: &str) -> Result<(), tree::MethodErr>;
    fn start_transient_unit(&self, name: &str, mode: &str, properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>, aux: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)>) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_unit_processes(&self, name: &str) -> Result<Vec<(String, u32, String)>, tree::MethodErr>;
    fn attach_processes_to_unit(&self, unit_name: &str, subcgroup: &str, pids: Vec<u32>) -> Result<(), tree::MethodErr>;
    fn abandon_scope(&self, name: &str) -> Result<(), tree::MethodErr>;
    fn get_job(&self, id: u32) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_job_after(&self, id: u32) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, tree::MethodErr>;
    fn get_job_before(&self, id: u32) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, tree::MethodErr>;
    fn cancel_job(&self, id: u32) -> Result<(), tree::MethodErr>;
    fn clear_jobs(&self) -> Result<(), tree::MethodErr>;
    fn reset_failed(&self) -> Result<(), tree::MethodErr>;
    fn set_show_status_(&self, mode: &str) -> Result<(), tree::MethodErr>;
    fn list_units(&self) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, tree::MethodErr>;
    fn list_units_filtered(&self, states: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, tree::MethodErr>;
    fn list_units_by_patterns(&self, states: Vec<&str>, patterns: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, tree::MethodErr>;
    fn list_units_by_names(&self, names: Vec<&str>) -> Result<Vec<(String, String, String, String, String, String, dbus::Path<'static>, u32, String, dbus::Path<'static>)>, tree::MethodErr>;
    fn list_jobs(&self) -> Result<Vec<(u32, String, String, String, dbus::Path<'static>, dbus::Path<'static>)>, tree::MethodErr>;
    fn subscribe(&self) -> Result<(), tree::MethodErr>;
    fn unsubscribe(&self) -> Result<(), tree::MethodErr>;
    fn dump(&self) -> Result<String, tree::MethodErr>;
    fn dump_by_file_descriptor(&self) -> Result<arg::OwnedFd, tree::MethodErr>;
    fn reload(&self) -> Result<(), tree::MethodErr>;
    fn reexecute(&self) -> Result<(), tree::MethodErr>;
    fn exit(&self) -> Result<(), tree::MethodErr>;
    fn reboot(&self) -> Result<(), tree::MethodErr>;
    fn power_off(&self) -> Result<(), tree::MethodErr>;
    fn halt(&self) -> Result<(), tree::MethodErr>;
    fn kexec(&self) -> Result<(), tree::MethodErr>;
    fn switch_root(&self, new_root: &str, init: &str) -> Result<(), tree::MethodErr>;
    fn set_environment_(&self, assignments: Vec<&str>) -> Result<(), tree::MethodErr>;
    fn unset_environment(&self, names: Vec<&str>) -> Result<(), tree::MethodErr>;
    fn unset_and_set_environment(&self, names: Vec<&str>, assignments: Vec<&str>) -> Result<(), tree::MethodErr>;
    fn list_unit_files(&self) -> Result<Vec<(String, String)>, tree::MethodErr>;
    fn list_unit_files_by_patterns(&self, states: Vec<&str>, patterns: Vec<&str>) -> Result<Vec<(String, String)>, tree::MethodErr>;
    fn get_unit_file_state(&self, file: &str) -> Result<String, tree::MethodErr>;
    fn enable_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn disable_unit_files(&self, files: Vec<&str>, runtime: bool) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn enable_unit_files_with_flags(&self, files: Vec<&str>, flags: u64) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn disable_unit_files_with_flags(&self, files: Vec<&str>, flags: u64) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn reenable_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn link_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn preset_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn preset_unit_files_with_mode(&self, files: Vec<&str>, mode: &str, runtime: bool, force: bool) -> Result<(bool, Vec<(String, String, String)>), tree::MethodErr>;
    fn mask_unit_files(&self, files: Vec<&str>, runtime: bool, force: bool) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn unmask_unit_files(&self, files: Vec<&str>, runtime: bool) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn revert_unit_files(&self, files: Vec<&str>) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn set_default_target(&self, name: &str, force: bool) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn get_default_target(&self) -> Result<String, tree::MethodErr>;
    fn preset_all_unit_files(&self, mode: &str, runtime: bool, force: bool) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn add_dependency_unit_files(&self, files: Vec<&str>, target: &str, type_: &str, runtime: bool, force: bool) -> Result<Vec<(String, String, String)>, tree::MethodErr>;
    fn get_unit_file_links(&self, name: &str, runtime: bool) -> Result<Vec<String>, tree::MethodErr>;
    fn set_exit_code_(&self, number: u8) -> Result<(), tree::MethodErr>;
    fn lookup_dynamic_user_by_name(&self, name: &str) -> Result<u32, tree::MethodErr>;
    fn lookup_dynamic_user_by_uid(&self, uid: u32) -> Result<String, tree::MethodErr>;
    fn get_dynamic_users(&self) -> Result<Vec<(u32, String)>, tree::MethodErr>;
    fn version(&self) -> Result<String, tree::MethodErr>;
    fn features(&self) -> Result<String, tree::MethodErr>;
    fn virtualization(&self) -> Result<String, tree::MethodErr>;
    fn architecture(&self) -> Result<String, tree::MethodErr>;
    fn tainted(&self) -> Result<String, tree::MethodErr>;
    fn firmware_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn firmware_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn loader_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn loader_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn kernel_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn kernel_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdtimestamp(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdtimestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn userspace_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn userspace_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn security_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn security_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn security_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn security_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn generators_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn generators_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn generators_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn generators_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn units_load_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn units_load_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn units_load_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn units_load_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdsecurity_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdsecurity_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdsecurity_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdsecurity_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdgenerators_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdgenerators_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdgenerators_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdgenerators_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdunits_load_start_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdunits_load_start_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdunits_load_finish_timestamp(&self) -> Result<u64, tree::MethodErr>;
    fn init_rdunits_load_finish_timestamp_monotonic(&self) -> Result<u64, tree::MethodErr>;
    fn log_level(&self) -> Result<String, tree::MethodErr>;
    fn set_log_level(&self, value: String) -> Result<(), tree::MethodErr>;
    fn log_target(&self) -> Result<String, tree::MethodErr>;
    fn set_log_target(&self, value: String) -> Result<(), tree::MethodErr>;
    fn nnames(&self) -> Result<u32, tree::MethodErr>;
    fn nfailed_units(&self) -> Result<u32, tree::MethodErr>;
    fn njobs(&self) -> Result<u32, tree::MethodErr>;
    fn ninstalled_jobs(&self) -> Result<u32, tree::MethodErr>;
    fn nfailed_jobs(&self) -> Result<u32, tree::MethodErr>;
    fn progress(&self) -> Result<f64, tree::MethodErr>;
    fn environment(&self) -> Result<Vec<String>, tree::MethodErr>;
    fn confirm_spawn(&self) -> Result<bool, tree::MethodErr>;
    fn show_status(&self) -> Result<bool, tree::MethodErr>;
    fn unit_path(&self) -> Result<Vec<String>, tree::MethodErr>;
    fn default_standard_output(&self) -> Result<String, tree::MethodErr>;
    fn default_standard_error(&self) -> Result<String, tree::MethodErr>;
    fn runtime_watchdog_usec(&self) -> Result<u64, tree::MethodErr>;
    fn set_runtime_watchdog_usec(&self, value: u64) -> Result<(), tree::MethodErr>;
    fn reboot_watchdog_usec(&self) -> Result<u64, tree::MethodErr>;
    fn set_reboot_watchdog_usec(&self, value: u64) -> Result<(), tree::MethodErr>;
    fn kexec_watchdog_usec(&self) -> Result<u64, tree::MethodErr>;
    fn set_kexec_watchdog_usec(&self, value: u64) -> Result<(), tree::MethodErr>;
    fn service_watchdogs(&self) -> Result<bool, tree::MethodErr>;
    fn set_service_watchdogs(&self, value: bool) -> Result<(), tree::MethodErr>;
    fn control_group(&self) -> Result<String, tree::MethodErr>;
    fn system_state(&self) -> Result<String, tree::MethodErr>;
    fn exit_code(&self) -> Result<u8, tree::MethodErr>;
    fn default_timer_accuracy_usec(&self) -> Result<u64, tree::MethodErr>;
    fn default_timeout_start_usec(&self) -> Result<u64, tree::MethodErr>;
    fn default_timeout_stop_usec(&self) -> Result<u64, tree::MethodErr>;
    fn default_timeout_abort_usec(&self) -> Result<u64, tree::MethodErr>;
    fn default_restart_usec(&self) -> Result<u64, tree::MethodErr>;
    fn default_start_limit_interval_usec(&self) -> Result<u64, tree::MethodErr>;
    fn default_start_limit_burst(&self) -> Result<u32, tree::MethodErr>;
    fn default_cpuaccounting(&self) -> Result<bool, tree::MethodErr>;
    fn default_block_ioaccounting(&self) -> Result<bool, tree::MethodErr>;
    fn default_memory_accounting(&self) -> Result<bool, tree::MethodErr>;
    fn default_tasks_accounting(&self) -> Result<bool, tree::MethodErr>;
    fn default_limit_cpu(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_cpusoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_fsize(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_fsizesoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_data(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_datasoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_stack(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_stacksoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_core(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_coresoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_rss(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_rsssoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_nofile(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_nofilesoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_as(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_assoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_nproc(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_nprocsoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_memlock(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_memlocksoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_locks(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_lockssoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_sigpending(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_sigpendingsoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_msgqueue(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_msgqueuesoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_nice(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_nicesoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_rtprio(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_rtpriosoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_rttime(&self) -> Result<u64, tree::MethodErr>;
    fn default_limit_rttimesoft(&self) -> Result<u64, tree::MethodErr>;
    fn default_tasks_max(&self) -> Result<u64, tree::MethodErr>;
    fn timer_slack_nsec(&self) -> Result<u64, tree::MethodErr>;
    fn default_oompolicy(&self) -> Result<String, tree::MethodErr>;
}

pub fn org_freedesktop_systemd1_manager_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    D::Signal: Default,
    T: OrgFreedesktopSystemd1Manager,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.systemd1.Manager", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        let unit = d.get_unit(name)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unit);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.out_arg(("unit", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let pid: u32 = i.read()?;
        let d = fclone(minfo);
        let unit = d.get_unit_by_pid(pid)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unit);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUnitByPID", Default::default(), h);
    let m = m.in_arg(("pid", "u"));
    let m = m.out_arg(("unit", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let invocation_id: Vec<u8> = i.read()?;
        let d = fclone(minfo);
        let unit = d.get_unit_by_invocation_id(invocation_id)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unit);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUnitByInvocationID", Default::default(), h);
    let m = m.in_arg(("invocation_id", "ay"));
    let m = m.out_arg(("unit", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let cgroup: &str = i.read()?;
        let d = fclone(minfo);
        let unit = d.get_unit_by_control_group(cgroup)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unit);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUnitByControlGroup", Default::default(), h);
    let m = m.in_arg(("cgroup", "s"));
    let m = m.out_arg(("unit", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        let unit = d.load_unit(name)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unit);
        Ok(vec!(rm))
    };
    let m = factory.method("LoadUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.out_arg(("unit", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        let job = d.start_unit(name, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("StartUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let old_unit: &str = i.read()?;
        let new_unit: &str = i.read()?;
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        let job = d.start_unit_replace(old_unit, new_unit, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("StartUnitReplace", Default::default(), h);
    let m = m.in_arg(("old_unit", "s"));
    let m = m.in_arg(("new_unit", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        let job = d.stop_unit(name, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("StopUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        let job = d.reload_unit(name, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("ReloadUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        let job = d.restart_unit(name, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("RestartUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        let job = d.try_restart_unit(name, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("TryRestartUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        let job = d.reload_or_restart_unit(name, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("ReloadOrRestartUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        let job = d.reload_or_try_restart_unit(name, mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("ReloadOrTryRestartUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let job_type: &str = i.read()?;
        let job_mode: &str = i.read()?;
        let d = fclone(minfo);
        let (job_id, job_path, unit_id, unit_path, job_type, affected_jobs) = d.enqueue_unit_job(name, job_type, job_mode)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job_id);
        let rm = rm.append1(job_path);
        let rm = rm.append1(unit_id);
        let rm = rm.append1(unit_path);
        let rm = rm.append1(job_type);
        let rm = rm.append1(affected_jobs);
        Ok(vec!(rm))
    };
    let m = factory.method("EnqueueUnitJob", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("job_type", "s"));
    let m = m.in_arg(("job_mode", "s"));
    let m = m.out_arg(("job_id", "u"));
    let m = m.out_arg(("job_path", "o"));
    let m = m.out_arg(("unit_id", "s"));
    let m = m.out_arg(("unit_path", "o"));
    let m = m.out_arg(("job_type", "s"));
    let m = m.out_arg(("affected_jobs", "a(uosos)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let whom: &str = i.read()?;
        let signal: i32 = i.read()?;
        let d = fclone(minfo);
        d.kill_unit(name, whom, signal)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("KillUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("whom", "s"));
    let m = m.in_arg(("signal", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mask: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.clean_unit(name, mask)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("CleanUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mask", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        d.freeze_unit(name)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("FreezeUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        d.thaw_unit(name)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ThawUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        d.reset_failed_unit(name)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ResetFailedUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let runtime: bool = i.read()?;
        let properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)> = i.read()?;
        let d = fclone(minfo);
        d.set_unit_properties(name, runtime, properties)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetUnitProperties", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("properties", "a(sv)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        d.ref_unit(name)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RefUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        d.unref_unit(name)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnrefUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let mode: &str = i.read()?;
        let properties: Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)> = i.read()?;
        let aux: Vec<(&str, Vec<(&str, arg::Variant<Box<dyn arg::RefArg>>)>)> = i.read()?;
        let d = fclone(minfo);
        let job = d.start_transient_unit(name, mode, properties, aux)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("StartTransientUnit", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("mode", "s"));
    let m = m.in_arg(("properties", "a(sv)"));
    let m = m.in_arg(("aux", "a(sa(sv))"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        let processes = d.get_unit_processes(name)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(processes);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUnitProcesses", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.out_arg(("processes", "a(sus)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let unit_name: &str = i.read()?;
        let subcgroup: &str = i.read()?;
        let pids: Vec<u32> = i.read()?;
        let d = fclone(minfo);
        d.attach_processes_to_unit(unit_name, subcgroup, pids)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("AttachProcessesToUnit", Default::default(), h);
    let m = m.in_arg(("unit_name", "s"));
    let m = m.in_arg(("subcgroup", "s"));
    let m = m.in_arg(("pids", "au"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        d.abandon_scope(name)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("AbandonScope", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let id: u32 = i.read()?;
        let d = fclone(minfo);
        let job = d.get_job(id)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(job);
        Ok(vec!(rm))
    };
    let m = factory.method("GetJob", Default::default(), h);
    let m = m.in_arg(("id", "u"));
    let m = m.out_arg(("job", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let id: u32 = i.read()?;
        let d = fclone(minfo);
        let jobs = d.get_job_after(id)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(jobs);
        Ok(vec!(rm))
    };
    let m = factory.method("GetJobAfter", Default::default(), h);
    let m = m.in_arg(("id", "u"));
    let m = m.out_arg(("jobs", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let id: u32 = i.read()?;
        let d = fclone(minfo);
        let jobs = d.get_job_before(id)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(jobs);
        Ok(vec!(rm))
    };
    let m = factory.method("GetJobBefore", Default::default(), h);
    let m = m.in_arg(("id", "u"));
    let m = m.out_arg(("jobs", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let id: u32 = i.read()?;
        let d = fclone(minfo);
        d.cancel_job(id)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("CancelJob", Default::default(), h);
    let m = m.in_arg(("id", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.clear_jobs()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ClearJobs", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reset_failed()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ResetFailed", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let mode: &str = i.read()?;
        let d = fclone(minfo);
        d.set_show_status_(mode)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetShowStatus", Default::default(), h);
    let m = m.in_arg(("mode", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let units = d.list_units()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(units);
        Ok(vec!(rm))
    };
    let m = factory.method("ListUnits", Default::default(), h);
    let m = m.out_arg(("units", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let states: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let units = d.list_units_filtered(states)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(units);
        Ok(vec!(rm))
    };
    let m = factory.method("ListUnitsFiltered", Default::default(), h);
    let m = m.in_arg(("states", "as"));
    let m = m.out_arg(("units", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let states: Vec<&str> = i.read()?;
        let patterns: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let units = d.list_units_by_patterns(states, patterns)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(units);
        Ok(vec!(rm))
    };
    let m = factory.method("ListUnitsByPatterns", Default::default(), h);
    let m = m.in_arg(("states", "as"));
    let m = m.in_arg(("patterns", "as"));
    let m = m.out_arg(("units", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let names: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let units = d.list_units_by_names(names)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(units);
        Ok(vec!(rm))
    };
    let m = factory.method("ListUnitsByNames", Default::default(), h);
    let m = m.in_arg(("names", "as"));
    let m = m.out_arg(("units", "a(ssssssouso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let jobs = d.list_jobs()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(jobs);
        Ok(vec!(rm))
    };
    let m = factory.method("ListJobs", Default::default(), h);
    let m = m.out_arg(("jobs", "a(usssoo)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.subscribe()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Subscribe", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.unsubscribe()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Unsubscribe", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let output = d.dump()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(output);
        Ok(vec!(rm))
    };
    let m = factory.method("Dump", Default::default(), h);
    let m = m.out_arg(("output", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let fd = d.dump_by_file_descriptor()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(fd);
        Ok(vec!(rm))
    };
    let m = factory.method("DumpByFileDescriptor", Default::default(), h);
    let m = m.out_arg(("fd", "h"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reload()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Reload", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reexecute()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Reexecute", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.exit()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Exit", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.reboot()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Reboot", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.power_off()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("PowerOff", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.halt()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Halt", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.kexec()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("KExec", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let new_root: &str = i.read()?;
        let init: &str = i.read()?;
        let d = fclone(minfo);
        d.switch_root(new_root, init)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SwitchRoot", Default::default(), h);
    let m = m.in_arg(("new_root", "s"));
    let m = m.in_arg(("init", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let assignments: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.set_environment_(assignments)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetEnvironment", Default::default(), h);
    let m = m.in_arg(("assignments", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let names: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.unset_environment(names)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnsetEnvironment", Default::default(), h);
    let m = m.in_arg(("names", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let names: Vec<&str> = i.read()?;
        let assignments: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        d.unset_and_set_environment(names, assignments)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnsetAndSetEnvironment", Default::default(), h);
    let m = m.in_arg(("names", "as"));
    let m = m.in_arg(("assignments", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let unit_files = d.list_unit_files()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unit_files);
        Ok(vec!(rm))
    };
    let m = factory.method("ListUnitFiles", Default::default(), h);
    let m = m.out_arg(("unit_files", "a(ss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let states: Vec<&str> = i.read()?;
        let patterns: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let unit_files = d.list_unit_files_by_patterns(states, patterns)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unit_files);
        Ok(vec!(rm))
    };
    let m = factory.method("ListUnitFilesByPatterns", Default::default(), h);
    let m = m.in_arg(("states", "as"));
    let m = m.in_arg(("patterns", "as"));
    let m = m.out_arg(("unit_files", "a(ss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let file: &str = i.read()?;
        let d = fclone(minfo);
        let state = d.get_unit_file_state(file)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(state);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUnitFileState", Default::default(), h);
    let m = m.in_arg(("file", "s"));
    let m = m.out_arg(("state", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let runtime: bool = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let (carries_install_info, changes) = d.enable_unit_files(files, runtime, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(carries_install_info);
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("EnableUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("carries_install_info", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let runtime: bool = i.read()?;
        let d = fclone(minfo);
        let changes = d.disable_unit_files(files, runtime)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("DisableUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let flags: u64 = i.read()?;
        let d = fclone(minfo);
        let (carries_install_info, changes) = d.enable_unit_files_with_flags(files, flags)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(carries_install_info);
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("EnableUnitFilesWithFlags", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("flags", "t"));
    let m = m.out_arg(("carries_install_info", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let flags: u64 = i.read()?;
        let d = fclone(minfo);
        let changes = d.disable_unit_files_with_flags(files, flags)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("DisableUnitFilesWithFlags", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("flags", "t"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let runtime: bool = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let (carries_install_info, changes) = d.reenable_unit_files(files, runtime, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(carries_install_info);
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("ReenableUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("carries_install_info", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let runtime: bool = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let changes = d.link_unit_files(files, runtime, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("LinkUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let runtime: bool = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let (carries_install_info, changes) = d.preset_unit_files(files, runtime, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(carries_install_info);
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("PresetUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("carries_install_info", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let mode: &str = i.read()?;
        let runtime: bool = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let (carries_install_info, changes) = d.preset_unit_files_with_mode(files, mode, runtime, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(carries_install_info);
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("PresetUnitFilesWithMode", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("mode", "s"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("carries_install_info", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let runtime: bool = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let changes = d.mask_unit_files(files, runtime, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("MaskUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let runtime: bool = i.read()?;
        let d = fclone(minfo);
        let changes = d.unmask_unit_files(files, runtime)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("UnmaskUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let d = fclone(minfo);
        let changes = d.revert_unit_files(files)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("RevertUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let changes = d.set_default_target(name, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("SetDefaultTarget", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let name = d.get_default_target()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(name);
        Ok(vec!(rm))
    };
    let m = factory.method("GetDefaultTarget", Default::default(), h);
    let m = m.out_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let mode: &str = i.read()?;
        let runtime: bool = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let changes = d.preset_all_unit_files(mode, runtime, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("PresetAllUnitFiles", Default::default(), h);
    let m = m.in_arg(("mode", "s"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let files: Vec<&str> = i.read()?;
        let target: &str = i.read()?;
        let type_: &str = i.read()?;
        let runtime: bool = i.read()?;
        let force: bool = i.read()?;
        let d = fclone(minfo);
        let changes = d.add_dependency_unit_files(files, target, type_, runtime, force)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(changes);
        Ok(vec!(rm))
    };
    let m = factory.method("AddDependencyUnitFiles", Default::default(), h);
    let m = m.in_arg(("files", "as"));
    let m = m.in_arg(("target", "s"));
    let m = m.in_arg(("type", "s"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.in_arg(("force", "b"));
    let m = m.out_arg(("changes", "a(sss)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let runtime: bool = i.read()?;
        let d = fclone(minfo);
        let links = d.get_unit_file_links(name, runtime)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(links);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUnitFileLinks", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("runtime", "b"));
    let m = m.out_arg(("links", "as"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let number: u8 = i.read()?;
        let d = fclone(minfo);
        d.set_exit_code_(number)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetExitCode", Default::default(), h);
    let m = m.in_arg(("number", "y"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        let uid = d.lookup_dynamic_user_by_name(name)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(uid);
        Ok(vec!(rm))
    };
    let m = factory.method("LookupDynamicUserByName", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.out_arg(("uid", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let uid: u32 = i.read()?;
        let d = fclone(minfo);
        let name = d.lookup_dynamic_user_by_uid(uid)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(name);
        Ok(vec!(rm))
    };
    let m = factory.method("LookupDynamicUserByUID", Default::default(), h);
    let m = m.in_arg(("uid", "u"));
    let m = m.out_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let users = d.get_dynamic_users()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(users);
        Ok(vec!(rm))
    };
    let m = factory.method("GetDynamicUsers", Default::default(), h);
    let m = m.out_arg(("users", "a(us)"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("Version", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.version()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Features", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.features()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Virtualization", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.virtualization()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Architecture", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.architecture()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Tainted", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.tainted()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FirmwareTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.firmware_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FirmwareTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.firmware_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("LoaderTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.loader_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("LoaderTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.loader_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KernelTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.kernel_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KernelTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.kernel_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdtimestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdtimestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UserspaceTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.userspace_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UserspaceTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.userspace_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("FinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.security_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.security_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.security_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SecurityFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.security_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.generators_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.generators_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.generators_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("GeneratorsFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.generators_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.units_load_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.units_load_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.units_load_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UnitsLoadFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.units_load_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdsecurity_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdsecurity_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdsecurity_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDSecurityFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdsecurity_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDGeneratorsStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdgenerators_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDGeneratorsStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdgenerators_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDGeneratorsFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdgenerators_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDGeneratorsFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdgenerators_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDUnitsLoadStartTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdunits_load_start_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDUnitsLoadStartTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdunits_load_start_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDUnitsLoadFinishTimestamp", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdunits_load_finish_timestamp()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InitRDUnitsLoadFinishTimestampMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.init_rdunits_load_finish_timestamp_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("LogLevel", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.log_level()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_log_level(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("LogTarget", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.log_target()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_log_target(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NNames", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nnames()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NFailedUnits", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nfailed_units()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.njobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NInstalledJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.ninstalled_jobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NFailedJobs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.nfailed_jobs()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<f64, _>("Progress", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.progress()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("Environment", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.environment()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ConfirmSpawn", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.confirm_spawn()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ShowStatus", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.show_status()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("UnitPath", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.unit_path()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultStandardOutput", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_standard_output()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultStandardError", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_standard_error()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("RuntimeWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.runtime_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_runtime_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("RebootWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.reboot_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_reboot_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("KExecWatchdogUSec", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.kexec_watchdog_usec()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_kexec_watchdog_usec(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ServiceWatchdogs", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.service_watchdogs()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_service_watchdogs(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("ControlGroup", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.control_group()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("SystemState", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.system_state()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u8, _>("ExitCode", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.exit_code()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimerAccuracyUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_timer_accuracy_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutStartUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_timeout_start_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutStopUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_timeout_stop_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTimeoutAbortUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_timeout_abort_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultRestartUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_restart_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultStartLimitIntervalUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_start_limit_interval_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("DefaultStartLimitBurst", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_start_limit_burst()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultCPUAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_cpuaccounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultBlockIOAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_block_ioaccounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultMemoryAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_memory_accounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("DefaultTasksAccounting", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_tasks_accounting()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCPU", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_cpu()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCPUSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_cpusoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitFSIZE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_fsize()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitFSIZESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_fsizesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitDATA", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_data()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitDATASoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_datasoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSTACK", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_stack()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSTACKSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_stacksoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCORE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_core()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitCORESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_coresoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRSS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_rss()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRSSSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_rsssoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNOFILE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_nofile()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNOFILESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_nofilesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitAS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_as()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitASSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_assoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNPROC", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_nproc()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNPROCSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_nprocsoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMEMLOCK", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_memlock()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMEMLOCKSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_memlocksoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitLOCKS", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_locks()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitLOCKSSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_lockssoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSIGPENDING", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_sigpending()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitSIGPENDINGSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_sigpendingsoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMSGQUEUE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_msgqueue()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitMSGQUEUESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_msgqueuesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNICE", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_nice()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitNICESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_nicesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTPRIO", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_rtprio()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTPRIOSoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_rtpriosoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTTIME", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_rttime()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultLimitRTTIMESoft", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_limit_rttimesoft()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("DefaultTasksMax", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_tasks_max()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("TimerSlackNSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.timer_slack_nsec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DefaultOOMPolicy", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.default_oompolicy()?);
        Ok(())
    });
    let i = i.add_p(p);
    let s = factory.signal("UnitNew", Default::default());
    let s = s.arg(("id", "s"));
    let s = s.arg(("unit", "o"));
    let i = i.add_s(s);
    let s = factory.signal("UnitRemoved", Default::default());
    let s = s.arg(("id", "s"));
    let s = s.arg(("unit", "o"));
    let i = i.add_s(s);
    let s = factory.signal("JobNew", Default::default());
    let s = s.arg(("id", "u"));
    let s = s.arg(("job", "o"));
    let s = s.arg(("unit", "s"));
    let i = i.add_s(s);
    let s = factory.signal("JobRemoved", Default::default());
    let s = s.arg(("id", "u"));
    let s = s.arg(("job", "o"));
    let s = s.arg(("unit", "s"));
    let s = s.arg(("result", "s"));
    let i = i.add_s(s);
    let s = factory.signal("StartupFinished", Default::default());
    let s = s.arg(("firmware", "t"));
    let s = s.arg(("loader", "t"));
    let s = s.arg(("kernel", "t"));
    let s = s.arg(("initrd", "t"));
    let s = s.arg(("userspace", "t"));
    let s = s.arg(("total", "t"));
    let i = i.add_s(s);
    let s = factory.signal("UnitFilesChanged", Default::default());
    let i = i.add_s(s);
    let s = factory.signal("Reloading", Default::default());
    let s = s.arg(("active", "b"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitNew {
    pub id: String,
    pub unit: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.unit, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitNew {
            id: i.read()?,
            unit: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitNew {
    const NAME: &'static str = "UnitNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitRemoved {
    pub id: String,
    pub unit: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.unit, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitRemoved {
            id: i.read()?,
            unit: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitRemoved {
    const NAME: &'static str = "UnitRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerJobNew {
    pub id: u32,
    pub job: dbus::Path<'static>,
    pub unit: String,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerJobNew {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.job, i);
        arg::RefArg::append(&self.unit, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerJobNew {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerJobNew {
            id: i.read()?,
            job: i.read()?,
            unit: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerJobNew {
    const NAME: &'static str = "JobNew";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerJobRemoved {
    pub id: u32,
    pub job: dbus::Path<'static>,
    pub unit: String,
    pub result: String,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerJobRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.job, i);
        arg::RefArg::append(&self.unit, i);
        arg::RefArg::append(&self.result, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerJobRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerJobRemoved {
            id: i.read()?,
            job: i.read()?,
            unit: i.read()?,
            result: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerJobRemoved {
    const NAME: &'static str = "JobRemoved";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerStartupFinished {
    pub firmware: u64,
    pub loader: u64,
    pub kernel: u64,
    pub initrd: u64,
    pub userspace: u64,
    pub total: u64,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerStartupFinished {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.firmware, i);
        arg::RefArg::append(&self.loader, i);
        arg::RefArg::append(&self.kernel, i);
        arg::RefArg::append(&self.initrd, i);
        arg::RefArg::append(&self.userspace, i);
        arg::RefArg::append(&self.total, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerStartupFinished {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerStartupFinished {
            firmware: i.read()?,
            loader: i.read()?,
            kernel: i.read()?,
            initrd: i.read()?,
            userspace: i.read()?,
            total: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerStartupFinished {
    const NAME: &'static str = "StartupFinished";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerUnitFilesChanged {
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerUnitFilesChanged {
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerUnitFilesChanged {
    const NAME: &'static str = "UnitFilesChanged";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}

#[derive(Debug)]
pub struct OrgFreedesktopSystemd1ManagerReloading {
    pub active: bool,
}

impl arg::AppendAll for OrgFreedesktopSystemd1ManagerReloading {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.active, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSystemd1ManagerReloading {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSystemd1ManagerReloading {
            active: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSystemd1ManagerReloading {
    const NAME: &'static str = "Reloading";
    const INTERFACE: &'static str = "org.freedesktop.systemd1.Manager";
}
